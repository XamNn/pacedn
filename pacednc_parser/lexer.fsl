{
module Pace.Compiler.Parsing.Lexer
open Pace.Compiler.Parsing.Parser
open Microsoft.FSharp.Text.Lexing
}

//regexes
let whitespace			= [' ' '\t']
let newline				= "\n\r" | '\n'
let lineCommentStart	= '/' '/'
let blockCommentStart	= "<!--"
let blockCommentEnd		= "--" (newline|whitespace)* '>
let markupStart			= "<!>"
let markupEnd			= "</!>"
let wordChar			= ['a'-'z' 'A'-'Z' '_']
let decDigit			= ['0'-'9']
let hexPrefix			= '0' ['x' 'X']
let hexDigit			= ['0'-'9' 'a'-'z' 'A'-'Z']
let binPrefix			= '0' ['b' 'B']
let binDigit			= ['0' '1']
let lowOperator			= ['-' '+' '!' '#' '¤' '%' '£' '$' '€' '´' '`' '~' ':' '=' '@' '?' '<' '>' '\\' '.']
let highOperator		= ['*' '/' '|' '&' '^']


let blockComment	= blockCommentStart _* blockCommentEnd
let markup			= markupStart _* markupEnd
let identifier		= wordChar(wordChar|decDigit)
let decIngeter		= decDigit
let decFractional	= decDigit+'.'decDigit+
let hexInteger		= hexPrefix hexDigit+
let binInteger		= binPrefix binDigit+
let string			= '"' _* '"'


//tokens
rule tokenize = parse
| whitespace	{ tokenize lexbuf }
| newline		{ lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf }

| identifier	{ ID(LexBuffer.LexemeString lexbuf) }

| '('			{ PARENOPEN }
| ')'			{ PARENCLOSE }
| '['			{ SQUAREOPEN }
| ']'			{ SQUARECLOSE }
| '{'			{ CURLYOPEN }
| '}'			{ CURLYCLOSE }
| '<'			{ ANGLEOPEN }
| '>'			{ ANGLECLOSE }

| '.'			{ PERIOD }
| ';'			{ SEMICOLON }
| ','			{ COMMA }
| '='			{ EQUALS }
| "=>"			{ LAMBDA }
| '@'			{ AT }
| '?'			{ QUESTION }

| "element"		{ ELEMENT }
| "class"		{ CLASS }
| "struct"		{ STRUCT }
| "return"		{ RETURN }
| "null"		{ NULL }
| "object"		{ OBJECT }
| "get"			{ GET }
| "set"			{ SET }
| "alias"		{ ALIAS }
| "if"			{ IF }
| "when"		{ THEN }
| "then"		{ THEN }
| "else"		{ ELSE }
| "break"		{ BREAK }
| "continue"	{ CONTINUE }
| "is"			{ IS }
| "import"		{ IMPORT }
| "config"		{ CONFIG }
| "main"		{ MAIN }
| "func"		{ FUNC }
| "public"		{ PUBLIC }
| "private"		{ PRIVATE }
| "visible"		{ VISIBLE }
| "this"		{ THIS }
| "init"		{ INIT }
| "for"			{ FOR }
| "yield"		{ YIELD }
| "implicit"	{ IMPLICIT }
| "automatic"	{ AUTOMATIC }
| "operator"	{ OPERATOR }
| "true"		{ TRUE }
| "false"		{ FALSE }
| "not"			{ NOT }
| "and"			{ AND }
| "or"			{ OR }

| markup		{ MARKUP }

| "global::"	{ GLOBAL }

| eof			{ EOF }